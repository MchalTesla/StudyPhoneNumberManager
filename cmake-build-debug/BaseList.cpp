//// Created by 26395 on 2023/6/1.//#include "BaseList.h"using namespace std;BaseList::BaseList(){    this->header = nullptr;    this->last = nullptr;    this->next = nullptr;}BaseList* BaseList::headerList(){    if(this->lastList() == nullptr){        this->header = this;    }    if(this->header == nullptr){        this->header = this->lastList()->headerList();    }    return(this->header);}BaseList* BaseList::endList(){    BaseList* end = this;    if(this->nextList() != nullptr){        end = this->nextList()->endList();    }    return end;}BaseList* BaseList::nextList(){    return(this->next);}BaseList* BaseList::lastList(){    return(this->last);}BaseList* BaseList::numberToList(int number){    if(number >= this->listLong()){        return(nullptr);    }    BaseList* node = this->headerList()->nextList();    for(int pointer = 0; pointer < number; pointer ++){        node = node->nextList();    }    return node;}int BaseList::listLong(){    BaseList* node = this->headerList();    int listNumber = 0;    do{        listNumber ++;        node = node->nextList();    }while(node != nullptr);    return(listNumber-1);}void BaseList::copy(void* newnode, void *oldnode){    {        ((BaseList*)newnode)->next = ((BaseList*)oldnode)->next;        ((BaseList*)newnode)->last = ((BaseList*)oldnode)->last;        ((BaseList*)newnode)->header = ((BaseList*)oldnode)->last;    }}void BaseList::insertBefore(void* newnode, void* node){    try {        if(newnode == nullptr || node == nullptr){throw "know node from nullptr";}        if(((BaseList*)node) == ((BaseList*)node)->headerList()){throw "Before the first node insert node is prohibited";}        ((BaseList*)newnode)->last = ((BaseList*)node)->lastList();        ((BaseList*)node)->last = ((BaseList*)newnode);        ((BaseList*)newnode)->lastList()->next = ((BaseList*)newnode);        ((BaseList*)newnode)->next = ((BaseList*)node);//        BaseList *temp = ((BaseList*)node)->nextList();//        ((BaseList*)node)->next = ((BaseList*)newnode);//        ((BaseList*)newnode)->last = ((BaseList*)node);//        ((BaseList*)newnode)->next = temp;    }catch(const char* msg){        cerr << msg << endl;    }}void BaseList::insertAfter(void* newnode, void* node){    try{        if(newnode == nullptr || node == nullptr){throw "know node from nullptr";}        ((BaseList*)newnode)->next = ((BaseList*)node)->nextList();        ((BaseList*)node)->next = ((BaseList*)newnode);        ((BaseList*)newnode)->nextList()->last = ((BaseList*)newnode);        ((BaseList*)newnode)->last = ((BaseList*)node);//        BaseList * temp = ((BaseList*)node)->lastList();//        ((BaseList*)node)->last = ((BaseList*)newnode);//        ((BaseList*)newnode)->next = ((BaseList*)node);//        ((BaseList*)newnode)->last = temp;    }catch(const char* msg){        cerr << msg << endl;    }}void BaseList::push(void* newnode){    try{        if(newnode == nullptr){throw "know node from nullptr";}        BaseList* temp = this->endList();        ((BaseList*)newnode)->last = temp;        ((BaseList*)newnode)->next = temp->nextList();        temp->next = ((BaseList*)newnode);    }catch(const char* msg){        cerr << msg << endl;    }}void BaseList::deleteList(void *node){    try{        if(node == nullptr){throw "know node from nullptr";}        ((BaseList*)node)->lastList()->next = ((BaseList*)node)->nextList();        if(((BaseList*)node)->nextList() != nullptr){            ((BaseList*)node)->nextList()->last = ((BaseList*)node)->lastList();        }        delete ((BaseList*)node);    }catch(const char* msg){        cerr << msg << endl;    }}void BaseList::deleteList(){    if(this->lastList() != nullptr){        this->lastList()->next = this->nextList();    }    if(this->nextList() != nullptr){        this->nextList()->last = this->lastList();    }    delete this;}void BaseList::coverList(void* newnode, void* node){    void* temp = this->test_NewNode();    this->copy(temp, newnode);    ((BaseList*)temp)->last = ((BaseList*)node)->lastList();    if(((BaseList*)node)->lastList() != nullptr){        ((BaseList*)node)->lastList()->next = ((BaseList*)temp);    }    ((BaseList*)temp)->next = ((BaseList*)node)->nextList();    if(((BaseList*)node)->nextList() != nullptr){        ((BaseList*)node)->nextList()->last = ((BaseList*)temp);    }    delete (BaseList*)node;}void BaseList::exchangeList(void *node_1, void *node_2){    BaseList* swap = ((BaseList*)node_1)->nextList();    ((BaseList*)node_1)->next = ((BaseList*)node_2)->nextList();    ((BaseList*)node_2)->next = swap;    if(((BaseList*)node_1)->nextList() != nullptr){        ((BaseList*)node_1)->nextList()->last = ((BaseList*)node_1);    }    if(((BaseList*)node_2)->nextList() != nullptr){        ((BaseList*)node_2)->nextList()->last = ((BaseList*)node_2);    }    swap = ((BaseList*)node_1)->lastList();    ((BaseList*)node_1)->last = ((BaseList*)node_2)->lastList();    ((BaseList*)node_2)->last = swap;    if(((BaseList*)node_1)->lastList() != nullptr){        ((BaseList*)node_1)->lastList()->next = ((BaseList*)node_1);    }    if(((BaseList*)node_2)->lastList() != nullptr){        ((BaseList*)node_2)->lastList()->next = ((BaseList*)node_2);    }}